"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[4611],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,f=d["".concat(l,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(f,i(i({ref:t},c),{},{components:n})):a.createElement(f,i({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5594:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={title:"Procedures",description:"Procedures are HeyVL's logical units of code.",sidebar_position:1},i="Procedures and Coprocedures",s={unversionedId:"heyvl/procs",id:"heyvl/procs",title:"Procedures",description:"Procedures are HeyVL's logical units of code.",source:"@site/docs/heyvl/procs.md",sourceDirName:"heyvl",slug:"/heyvl/procs",permalink:"/docs/heyvl/procs",draft:!1,editUrl:"https://github.com/moves-rwth/caesar/tree/main/website/docs/heyvl/procs.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Procedures",description:"Procedures are HeyVL's logical units of code.",sidebar_position:1},sidebar:"docsSidebar",previous:{title:"HeyVL",permalink:"/docs/heyvl/"},next:{title:"Statements",permalink:"/docs/heyvl/statements"}},l={},p=[{value:"Example",id:"example",level:2},{value:"Verification of Procedures",id:"verification-of-procedures",level:2},{value:"Verification Encoding Internals",id:"verification-encoding-internals",level:3},{value:"Calling Procedures",id:"calling-procedures",level:2},{value:"Procedure Call Internals",id:"procedure-call-internals",level:3}],c={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"procedures-and-coprocedures"},"Procedures and Coprocedures"),(0,r.kt)("p",null,"HeyVL ",(0,r.kt)("a",{parentName:"p",href:"/docs/heyvl/statements"},"statements")," are placed inside the body of ",(0,r.kt)("em",{parentName:"p"},"(co)procedures")," or ",(0,r.kt)("em",{parentName:"p"},"(co)procs")," for short.\nA ",(0,r.kt)("em",{parentName:"p"},"procedure")," has a name, a list of parameters, a list of return values, and a list of specification attributes.\nCaesar tries to verify each procedure in the given HeyVL files using the specification.\n",(0,r.kt)("em",{parentName:"p"},"Coprocedures")," are like procedures, but the specification is interpreted differently (see below)."),(0,r.kt)("p",null,"Procedures can be called inside other procedures.\nThis enables modular reasoning about code: Prove that some code satisfies the specification once, and then use the specification when at the call site - without reasoning about the procedure's body again."),(0,r.kt)("p",null,"There are also procedures without an associated body.\nThey are not verified by Caesar, but can be called inside other procedures."),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"The following procedure named ",(0,r.kt)("inlineCode",{parentName:"p"},"forty_two")," accepts a single parameter, ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"UInt")," and returns a value ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"UInt"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"proc forty_two(x: UInt) -> (y: UInt)\n    pre ?(x == 41)\n    post ?(y == 42)\n{\n    y = x + 1;\n}\n")),(0,r.kt)("p",null,"There are two specification attributes: ",(0,r.kt)("inlineCode",{parentName:"p"},"pre")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"post"),".\nIntuitively, both attributes assert that if ",(0,r.kt)("inlineCode",{parentName:"p"},"forty_two")," is called with ",(0,r.kt)("inlineCode",{parentName:"p"},"x == 41"),", the result ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," will have value ",(0,r.kt)("inlineCode",{parentName:"p"},"42"),".\nThe expressions inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"pre")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"post")," statements are expectations, i.e. have type ",(0,r.kt)("a",{parentName:"p",href:"/docs/stdlib/numbers#eureal"},(0,r.kt)("inlineCode",{parentName:"a"},"EUReal")),".\nWe use ",(0,r.kt)("a",{parentName:"p",href:"/docs/heyvl/expressions"},"embed expressions")," to convert Boolean expressions to ",(0,r.kt)("inlineCode",{parentName:"p"},"EUReal")," values.\nThe procedure has a body with just a single assignment statement that increments ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," by 1 and saves the result in ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,r.kt)("p",null,"Writing ",(0,r.kt)("inlineCode",{parentName:"p"},"coproc")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"proc")," will will do an upper bound check for verification instead of a lower bound one."),(0,r.kt)("p",null,"The specification is optional; if it's not provided, Caesar will add a default specification: ",(0,r.kt)("inlineCode",{parentName:"p"},"pre ?(true)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"post ?(true)")," for procedures and ",(0,r.kt)("inlineCode",{parentName:"p"},"pre ?(false)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"post ?(false)")," for coprocedures."),(0,r.kt)("h2",{id:"verification-of-procedures"},"Verification of Procedures"),(0,r.kt)("p",null,"If a procedure has a body with statements, then Caesar will try to verify the procedure based on the specification attributes.\nThe verificiation of procedures can be entirely framed as a verification of HeyVL statements."),(0,r.kt)("h3",{id:"verification-encoding-internals"},"Verification Encoding Internals"),(0,r.kt)("p",null,"To verify the ",(0,r.kt)("inlineCode",{parentName:"p"},"forty_two")," procedure, Caesar generates the following HeyVL statements:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"assume ?(x == 41)\ny = x + 1;\nassert ?(y == 42)\n")),(0,r.kt)("p",null,"Each ",(0,r.kt)("inlineCode",{parentName:"p"},"pre")," attribute generates an ",(0,r.kt)("inlineCode",{parentName:"p"},"assume"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"coassume")," statement at the beginning.\nThen the unmodified procedure body follows.\nAfter that, an ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"coassert")," statement is generated for each ",(0,r.kt)("inlineCode",{parentName:"p"},"post")," attribute."),(0,r.kt)("p",null,"For coprocedures, the generated HeyVL statements will be preceded by a ",(0,r.kt)("inlineCode",{parentName:"p"},"negate")," and ended by a ",(0,r.kt)("inlineCode",{parentName:"p"},"conegate")," statement."),(0,r.kt)("h2",{id:"calling-procedures"},"Calling Procedures"),(0,r.kt)("p",null,"Procedures can be called inside other procedures.\nJust like for the verification task, a call of a procedure is replaced by a sequence of HeyVL statements based on the specification."),(0,r.kt)("h3",{id:"procedure-call-internals"},"Procedure Call Internals"),(0,r.kt)("p",null,"A call to ",(0,r.kt)("inlineCode",{parentName:"p"},"forty_two"),", e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"y = forty_two(x);")," is replaced by three basic HeyVL statements:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"assert ?(x == 41)\nhavoc y\nvalidate\nassume ?(y == 42)\n")),(0,r.kt)("p",null,"Now we ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," each ",(0,r.kt)("inlineCode",{parentName:"p"},"pre")," to ensure that the preceding code has actually established the pre-condition.\nThen we ",(0,r.kt)("inlineCode",{parentName:"p"},"havoc")," the modified variable ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),".\nAt this point, we know nothing about the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),".\nAt the end, we ",(0,r.kt)("inlineCode",{parentName:"p"},"assume")," the expression from the ",(0,r.kt)("inlineCode",{parentName:"p"},"post")," attribute.\nNow we know ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," has value ",(0,r.kt)("inlineCode",{parentName:"p"},"42"),".\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"validate")," statement is necessary to encode a Boolean check against the post."),(0,r.kt)("p",null,"The body of the procedure is not used to encode a procedure call.\nThis is why it is also possible to declare ",(0,r.kt)("inlineCode",{parentName:"p"},"forty_two")," without an associated body, but still call it inside another procedure."),(0,r.kt)("p",null,"You can find more details in our ",(0,r.kt)("a",{parentName:"p",href:"/docs/publications#oopsla-23"},"OOPLSA '23 paper"),"."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Right now, you can call procedures inside coprocedures and vice-versa.\nThis is basically never sound.\nWe'll fix that soon.")))}u.isMDXComponent=!0}}]);