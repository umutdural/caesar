"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[4118],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,h=u["".concat(l,".").concat(c)]||u[c]||m[c]||o;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3901:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294),i=n(3743);const o={tableOfContentsInline:"tableOfContentsInline_prmo"};function r(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:r}=e;return a.createElement("div",{className:o.tableOfContentsInline},a.createElement(i.Z,{toc:t,minHeadingLevel:n,maxHeadingLevel:r,className:"table-of-contents",linkClassName:null}))}},3743:(e,t,n)=>{n.d(t,{Z:()=>h});var a=n(7462),i=n(7294),o=n(6668);function r(e){const t=e.map((e=>({...e,parentIndex:-1,children:[]}))),n=Array(7).fill(-1);t.forEach(((e,t)=>{const a=n.slice(2,e.level);e.parentIndex=Math.max(...a),n[e.level]=t}));const a=[];return t.forEach((e=>{const{parentIndex:n,...i}=e;n>=0?t[n].children.push(i):a.push(i)})),a}function s(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:a}=e;return t.flatMap((e=>{const t=s({toc:e.children,minHeadingLevel:n,maxHeadingLevel:a});return function(e){return e.level>=n&&e.level<=a}(e)?[{...e,children:t}]:t}))}function l(e){const t=e.getBoundingClientRect();return t.top===t.bottom?l(e.parentNode):t}function p(e,t){let{anchorTopOffset:n}=t;const a=e.find((e=>l(e).top>=n));if(a){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(l(a))?a:e[e.indexOf(a)-1]??null}return e[e.length-1]??null}function d(){const e=(0,i.useRef)(0),{navbar:{hideOnScroll:t}}=(0,o.L)();return(0,i.useEffect)((()=>{e.current=t?0:document.querySelector(".navbar").clientHeight}),[t]),e}function u(e){const t=(0,i.useRef)(void 0),n=d();(0,i.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:a,linkActiveClassName:i,minHeadingLevel:o,maxHeadingLevel:r}=e;function s(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(a),s=function(e){let{minHeadingLevel:t,maxHeadingLevel:n}=e;const a=[];for(let i=t;i<=n;i+=1)a.push(`h${i}.anchor`);return Array.from(document.querySelectorAll(a.join()))}({minHeadingLevel:o,maxHeadingLevel:r}),l=p(s,{anchorTopOffset:n.current}),d=e.find((e=>l&&l.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,n){n?(t.current&&t.current!==e&&t.current.classList.remove(i),e.classList.add(i),t.current=e):e.classList.remove(i)}(e,e===d)}))}return document.addEventListener("scroll",s),document.addEventListener("resize",s),s(),()=>{document.removeEventListener("scroll",s),document.removeEventListener("resize",s)}}),[e,n])}function m(e){let{toc:t,className:n,linkClassName:a,isChild:o}=e;return t.length?i.createElement("ul",{className:o?void 0:n},t.map((e=>i.createElement("li",{key:e.id},i.createElement("a",{href:`#${e.id}`,className:a??void 0,dangerouslySetInnerHTML:{__html:e.value}}),i.createElement(m,{isChild:!0,toc:e.children,className:n,linkClassName:a}))))):null}const c=i.memo(m);function h(e){let{toc:t,className:n="table-of-contents table-of-contents__left-border",linkClassName:l="table-of-contents__link",linkActiveClassName:p,minHeadingLevel:d,maxHeadingLevel:m,...h}=e;const f=(0,o.L)(),k=d??f.tableOfContents.minHeadingLevel,v=m??f.tableOfContents.maxHeadingLevel,g=function(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:a}=e;return(0,i.useMemo)((()=>s({toc:r(t),minHeadingLevel:n,maxHeadingLevel:a})),[t,n,a])}({toc:t,minHeadingLevel:k,maxHeadingLevel:v});return u((0,i.useMemo)((()=>{if(l&&p)return{linkClassName:l,linkActiveClassName:p,minHeadingLevel:k,maxHeadingLevel:v}}),[l,p,k,v])),i.createElement(c,(0,a.Z)({toc:g,className:n,linkClassName:l},h))}},2090:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>p,toc:()=>u});var a=n(7462),i=(n(7294),n(3905)),o=(n(614),n(9960)),r=n(3901);const s={description:"A guide to understanding and verifying HeyVL.",sidebar_position:2},l="Guide to HeyVL",p={unversionedId:"getting-started/heyvl-guide",id:"getting-started/heyvl-guide",title:"Guide to HeyVL",description:"A guide to understanding and verifying HeyVL.",source:"@site/docs/getting-started/heyvl-guide.md",sourceDirName:"getting-started",slug:"/getting-started/heyvl-guide",permalink:"/docs/getting-started/heyvl-guide",draft:!1,editUrl:"https://github.com/moves-rwth/caesar/tree/main/website/docs/getting-started/heyvl-guide.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{description:"A guide to understanding and verifying HeyVL.",sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Installing Caesar",permalink:"/docs/getting-started/installation"},next:{title:"A Zoo of HeyVL Examples",permalink:"/docs/getting-started/zoo-of-heyvl-examples"}},d={},u=[{value:"Contents of this guide",id:"contents-of-this-guide",level:4},{value:"What are HeyVL and Caesar?",id:"what-are-heyvl-and-caesar",level:2},{value:"Architecture",id:"architecture",level:3},{value:"Features",id:"features",level:3},{value:"Verifying Our First Program: Lossy List Traversal",id:"verifying-our-first-program-lossy-list-traversal",level:2},{value:"The Probabilistic Program Itself",id:"the-probabilistic-program-itself",level:3},{value:"What does the program do?",id:"what-does-the-program-do",level:4},{value:"What do we want to verify?",id:"what-do-we-want-to-verify",level:4},{value:"User-Defined Datatypes and Functions",id:"user-defined-datatypes-and-functions",level:3},{value:"The List Type",id:"the-list-type",level:4},{value:"The Exponential Function",id:"the-exponential-function",level:4},{value:"Specifications and Invariants",id:"specifications-and-invariants",level:3},{value:"Specifications",id:"specifications",level:4},{value:"Invariants and Other Proof Rules",id:"invariants",level:4},{value:"Running the Complete Example",id:"full-example",level:3},{value:"Reasoning About Upper Bounds (Coprocedures)",id:"upper-bounds",level:3},{value:"Verification Statements",id:"verification-statements",level:2},{value:"Boolean Verification Statements",id:"boolean-verification-statements",level:3},{value:"Embed Expressions",id:"embed-expressions",level:4},{value:"Boolean Assertions",id:"boolean-assertions",level:4},{value:"Boolean Assumptions",id:"boolean-assumptions",level:4},{value:"Expectation-Based Reasoning",id:"expectation-based-reasoning",level:3},{value:"Assumptions and Assertions",id:"assumptions-and-assertions",level:3},{value:"Havoc",id:"havoc",level:3},{value:"Nondeterministic Choice",id:"nondeterministic-choice",level:3},{value:"Rewards",id:"rewards",level:3}],m={toc:u},c="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"guide-to-heyvl"},"Guide to HeyVL"),(0,i.kt)("p",null,"After ",(0,i.kt)("a",{parentName:"p",href:"/docs/getting-started/installation"},"installing Caesar"),", we can start to use HeyVL with Caesar.\nIn this guide, we'll go through the basics of HeyVL and how verification problems can be encoded in it.\nWe'll use the ",(0,i.kt)("em",{parentName:"p"},"lossy list")," example from our ",(0,i.kt)("a",{parentName:"p",href:"/"},"home page")," to understand HeyVL.\nOn the next page, we present ",(0,i.kt)("a",{parentName:"p",href:"/docs/getting-started/zoo-of-heyvl-examples"},"a collection of HeyVL examples"),"."),(0,i.kt)("h4",{id:"contents-of-this-guide"},"Contents of this guide"),(0,i.kt)(r.Z,{toc:u,mdxType:"TOCInline"}),(0,i.kt)("h2",{id:"what-are-heyvl-and-caesar"},"What are HeyVL and Caesar?"),(0,i.kt)("h3",{id:"architecture"},"Architecture"),(0,i.kt)("figure",{style:{"max-width":"400px",float:"right",width:"100%",border:"1px solid gray",padding:"1em","border-radius":"5px"}},(0,i.kt)("h3",{style:{"text-align":"center"}},"Architecture of Caesar"),(0,i.kt)("img",{src:"/img/architecture-oopsla23.svg"})),(0,i.kt)("p",null,"On the right, you can see the architecture of Caesar.\nCaesar is designed as a ",(0,i.kt)("em",{parentName:"p"},"deductive verification infrastructure")," for probabilistic programs."),(0,i.kt)("p",null,"At the core is ",(0,i.kt)("em",{parentName:"p"},"HeyVL"),", our ",(0,i.kt)("em",{parentName:"p"},"intermediate verification language")," (IVL).\nAn IVL is used to encode a wide range of verification problems and verification techniques into a common language.\nIn contrast to normal programming languages, IVLs can feature statements such as ",(0,i.kt)("inlineCode",{parentName:"p"},"assert")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"assume"),".\nIntuitively, ",(0,i.kt)("inlineCode",{parentName:"p"},"assert")," checks a condition and fails if it's not true.\n",(0,i.kt)("inlineCode",{parentName:"p"},"assume")," lets us make a logical assumption at arbitrary points in the program.\nThese can be used to encode proofs and proof rules into the IVL.\nHeyVL is a ",(0,i.kt)("em",{parentName:"p"},"quantitative")," IVL, meaning that its verification statements (",(0,i.kt)("inlineCode",{parentName:"p"},"assert"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"assume"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"havoc"),"...) do not only reason about Boolean statements (",(0,i.kt)("inlineCode",{parentName:"p"},"x = 3"),"), but rather about quantities such as expected values (",(0,i.kt)("inlineCode",{parentName:"p"},"[x = 3] * 0.5"),")."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"verification condition generator")," (VC generator) takes a HeyVL program and converts it to ",(0,i.kt)("em",{parentName:"p"},"verification conditions"),", which is a logical formula in our quantative logic ",(0,i.kt)("em",{parentName:"p"},"HeyLo"),".\nThis formula specifies logically whether a HeyVL program verifies or not.\nFor example, ",(0,i.kt)("inlineCode",{parentName:"p"},"assume [x = 3]; assert 0.5")," is converted to the HeyLo formula ",(0,i.kt)("inlineCode",{parentName:"p"},"[x = 3] \u2192 0.5"),".\nWe will explain what this means later in this guide (see the section on ",(0,i.kt)("a",{parentName:"p",href:"#verification-statements"},"verification statements"),").\nAt the end, Caesar converts the HeyLo formula into a problem for an ",(0,i.kt)("em",{parentName:"p"},"SMT solver"),"; currently we use ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Z3Prover/z3"},"Z3"),".\nThis allows us to check whether a program verifies ",(0,i.kt)("em",{parentName:"p"},"for all possible inputs"),".\nIf verification fails, then the SMT solver can often return a counter-example, i.e. an input to the program so that the program does not verify."),(0,i.kt)("p",null,"Caesar supports a number of proof rules out of the box (see ",(0,i.kt)("a",{parentName:"p",href:"../proof-rules/"},"proof rules documentation"),").\nFor example, reasoning about ",(0,i.kt)("em",{parentName:"p"},"while loops")," or recursion is done through proof rules.\nBy adding an annotation such as ",(0,i.kt)("a",{parentName:"p",href:"/docs/proof-rules/induction"},(0,i.kt)("inlineCode",{parentName:"a"},"@invariant"))," to a while loop, you can instruct Caesar use the ",(0,i.kt)("em",{parentName:"p"},"Park induction")," proof rule.\nHowever, this will internally desugar into normal HeyVL code which means these proof rules are ",(0,i.kt)("em",{parentName:"p"},"not")," magic built-ins, but just a convenience in Caesar.\nThus, you can add your own proof rules with Caesar by encoding them in HeyVL.\nThat is the advantage of using an intermediate verification language such as HeyVL."),(0,i.kt)("div",{style:{clear:"both"}}),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The language HeyVL and the basics of Caesar are formally described in our ",(0,i.kt)("a",{parentName:"p",href:"/docs/publications#oospla-23"},"OOPLSA '23 publication ",(0,i.kt)("em",{parentName:"a"},'"A Deductive Verification Infrastructure for Probabilistic Programs"'))," (",(0,i.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/2309.07781.pdf"},"direct link to extended version pdf"),").\nThere, you can find rock-solid formal foundations for HeyVL and details on how to prove that HeyVL programs are ",(0,i.kt)("em",{parentName:"p"},"correct"),", i.e. actually encode the desired verification problems.\nWe highly recommend you take a look at it after reading this guide for a more rigorous treatment of HeyVL and Caesar.\nRefer to our ",(0,i.kt)("a",{parentName:"p",href:"/docs/publications#oopsla-23"},"publications page")," for more details.")),(0,i.kt)("h3",{id:"features"},"Features"),(0,i.kt)("p",null,"So, what can we do with HeyVL and Caesar right now?\nHere's an incomplete list of features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Prove correctness and find bugs in probabilistic programs.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"We have verified properties like lower and upper bounds on expected values, such as expected values on termination, expected runtimes, expected resource consumption, termination probabilities, and more."),(0,i.kt)("li",{parentName:"ul"},"Using proof rules like Park induction, k-induction, rules for positive almost-sure and almost-sure termination, or the optional stopping theorem."))),(0,i.kt)("li",{parentName:"ul"},"Use ",(0,i.kt)("em",{parentName:"li"},"HeyVL"),", a ",(0,i.kt)("em",{parentName:"li"},"quantitative")," intermediate verification language that",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"has generalized quantitative verification statements ",(0,i.kt)("inlineCode",{parentName:"li"},"assume"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"assert"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"havoc"),", and nondeterministic choice,"),(0,i.kt)("li",{parentName:"ul"},"features dual ",(0,i.kt)("em",{parentName:"li"},"co"),"-versions of verification statements to reason about ",(0,i.kt)("em",{parentName:"li"},"upper bounds")," of expected values (the non-",(0,i.kt)("inlineCode",{parentName:"li"},"co")," statements are used to reason about ",(0,i.kt)("em",{parentName:"li"},"lower bounds"),"),"),(0,i.kt)("li",{parentName:"ul"},"and through these allows you to encode new proof rules and use Caesar as a verifier for them."))),(0,i.kt)("li",{parentName:"ul"},"Leverage the power of modern SMT solvers to logically reason about infinite-state probabilistic systems with infinitely many inputs and outputs, and unbounded loops and recursion."),(0,i.kt)("li",{parentName:"ul"},"Compositionally reason about programs, building bigger verified programs out of smaller verified parts using procedures."),(0,i.kt)("li",{parentName:"ul"},"Define your own data types and define new functions in HeyVL, with support for ",(0,i.kt)("em",{parentName:"li"},"uninterpreted")," definitions, i.e. those defined by logical ",(0,i.kt)("em",{parentName:"li"},"axioms")," and thus may not even have an executable definition."),(0,i.kt)("li",{parentName:"ul"},"Formally correct reasoning with theoretical guarantees. We do not use sampling algorithms such as ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo"},"MCMC"),", but instead use logical reasoning about programs.")),(0,i.kt)("h2",{id:"verifying-our-first-program-lossy-list-traversal"},"Verifying Our First Program: Lossy List Traversal"),(0,i.kt)("p",null,"Let us now go through the lossy list example in detail and step-by-step.\nThe ",(0,i.kt)("a",{parentName:"p",href:"#full-example"},"full example can be found below"),"."),(0,i.kt)("h3",{id:"the-probabilistic-program-itself"},"The Probabilistic Program Itself"),(0,i.kt)("p",null,"Let us start with the probabilistic program itself, without any HeyVL annotations.\n",(0,i.kt)("inlineCode",{parentName:"p"},"lossy_list")," is a procedure that takes an input ",(0,i.kt)("inlineCode",{parentName:"p"},"init_L")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," and returns an output list ",(0,i.kt)("inlineCode",{parentName:"p"},"l"),".\n",(0,i.kt)("inlineCode",{parentName:"p"},"List")," is a user-defined type ",(0,i.kt)("a",{parentName:"p",href:"#user-defined-datatypes-and-functions"},"which we define below"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-heyvl"},"proc lossy_list(init_l: List) -> (l: List)\n{\n    l = init_l\n    while len(l) > 0 {\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice {\n            l = pop(l)\n        } else {\n            assert [false]\n        }\n    }\n}\n")),(0,i.kt)("p",null,"The program is supposed to model a list traversal with a (rather alarming) 50% probability of memory faults during the traversal.\nFor this guide, we want to prove a lower bound to the probability of a successful traversal."),(0,i.kt)("h4",{id:"what-does-the-program-do"},"What does the program do?"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"We initialize the output ",(0,i.kt)("inlineCode",{parentName:"p"},"l")," to the input.\nNote that it's forbidden in HeyVL to modify input variables.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The main part of the code is the ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," loop.\nIt runs as long as the list ",(0,i.kt)("inlineCode",{parentName:"p"},"l")," is not zero."),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"In the loop body, we have our ",(0,i.kt)("em",{parentName:"p"},"probabilistic statement"),": The ",(0,i.kt)("inlineCode",{parentName:"p"},"flip(0.5)")," expression does a coin flip and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", each with probability ",(0,i.kt)("inlineCode",{parentName:"p"},"0.5"),".\nThe result is saved in a newly declared variable ",(0,i.kt)("inlineCode",{parentName:"p"},"prob_choice")," using the ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," statement.\nWhen we declare a new variable in HeyVL, we always need to specify the type.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If the coin flip resulted in ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", then we remove the first element of the top of the list using ",(0,i.kt)("inlineCode",{parentName:"p"},"pop"),".\nThe resulting list has a length that's one smaller than before.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If the coin flip resulted in ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", then we simulate a memory fault using ",(0,i.kt)("inlineCode",{parentName:"p"},"assert [false]"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("small",null,"Note: In HeyVL, while loops always need invariant annotations. Therefore, this program is not yet valid HeyVL code. We'll add the annotation ",(0,i.kt)(o.Z,{to:"#specifications",mdxType:"Link"},"when we talk about specifications"),".")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"HeyVL does not have ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statements. Every value to be returned by the procedure must be declared as an output variable in the procedure declaration. Here, the output variable ",(0,i.kt)("inlineCode",{parentName:"p"},"l")," is automatically returned."))),(0,i.kt)("p",null,"There is more detailed documentation on HeyVL's ",(0,i.kt)("a",{parentName:"p",href:"/docs/heyvl/procs"},"procedures")," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/heyvl/statements"},"statements"),"."),(0,i.kt)("h4",{id:"what-do-we-want-to-verify"},"What do we want to verify?"),(0,i.kt)("p",null,"With Caesar, various properties of this program can be verified:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"In this guide, we'll only verify that he probability of a successful run without crashing is at least ",(0,i.kt)("inlineCode",{parentName:"strong"},"0.5^len(init_l)"),".")),(0,i.kt)("li",{parentName:"ul"},"We could verify probabilities of crashing at specific list lengths."),(0,i.kt)("li",{parentName:"ul"},"We could verify expected values of list lengths at crash time."),(0,i.kt)("li",{parentName:"ul"},"For the above, we can verify either ",(0,i.kt)("em",{parentName:"li"},"lower")," or ",(0,i.kt)("em",{parentName:"li"},"upper bounds"),"."),(0,i.kt)("li",{parentName:"ul"},"The program is ",(0,i.kt)("em",{parentName:"li"},"certainly terminating"),", i.e. each execution will always terminate in a finite number of steps.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"There are programs that only terminate with probability one, but may have a zero probability of not terminating. We call these programs ",(0,i.kt)("em",{parentName:"li"},"almost-surely terminating")," (",(0,i.kt)("em",{parentName:"li"},"AST")," for short)."),(0,i.kt)("li",{parentName:"ul"},"There are programs which terminate with probability one, but do not have a finite expected runtime. Such programs are almost-surely terminating, but not ",(0,i.kt)("em",{parentName:"li"},"positively almost-surely terminating")," (",(0,i.kt)("em",{parentName:"li"},"PAST")," for short)."))),(0,i.kt)("li",{parentName:"ul"},"... and many more.")),(0,i.kt)("h3",{id:"user-defined-datatypes-and-functions"},"User-Defined Datatypes and Functions"),(0,i.kt)("p",null,"Our probbabilistic program above is incomplete: it's still missing a specification and a loop invariant annotation.\nIn addition, the ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," type and the ",(0,i.kt)("inlineCode",{parentName:"p"},"exp")," function need to be defined.\nThey are not built-in into HeyVL, but must be ",(0,i.kt)("em",{parentName:"p"},"axiomatized")," using user-defined domains and functions."),(0,i.kt)("p",null,"How this works is that domains and functions are defined ",(0,i.kt)("em",{parentName:"p"},"uninterpreted"),", which means that they do not necessarily need to have a complete executable definition associated with them.\nDomains are simply new types which functions can map from and into.\nFunctions simply have input and output types."),(0,i.kt)("p",null,"Then, ",(0,i.kt)("em",{parentName:"p"},"axioms")," define the knowledge that Caesar (and the underlying SMT solver) will receive about these uninterpreted domains and functions.\nFor the purpose of verification, we check all possible definitions which satisfy these axioms and ignore those that do not satisfy them."),(0,i.kt)("h4",{id:"the-list-type"},"The List Type"),(0,i.kt)("p",null,"Let's declare our list type, using the ",(0,i.kt)("a",{parentName:"p",href:"/docs/stdlib/numbers#uint"},"built-in ",(0,i.kt)("inlineCode",{parentName:"a"},"UInt")," type")," for nonnegative integers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-heyvl"},"domain List {\n    func len(l: List): UInt\n    func pop(l: List): List\n\n    axiom list_pop forall l: List. len(pop(l)) == len(l) - 1\n}\n")),(0,i.kt)("p",null,"You will notice that we do not declare what a list consists or what size the data type should have.\nWe simply declare a domain ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," and have two uninterpreted functions ",(0,i.kt)("inlineCode",{parentName:"p"},"len")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pop")," operating on this type.\nThey also don't have definitions, but only the axiom ",(0,i.kt)("inlineCode",{parentName:"p"},"list_pop")," that says the length will decrease by one if we run ",(0,i.kt)("inlineCode",{parentName:"p"},"pop")," on a list ",(0,i.kt)("inlineCode",{parentName:"p"},"l"),"."),(0,i.kt)("p",null,"These uninterpreted definitions are part of the magic of deductive verification using SMT solving that Caesar does.\nWe can simply define new types and functions ",(0,i.kt)("em",{parentName:"p"},"logically")," via a (possibly partial) specification and verify with those.\nThis makes Caesar very extensible: new definitions do not need to be baked into Caesar itself, but can be defined by the user.\nThis makes axioms also extremely dangerous. Consider ",(0,i.kt)("inlineCode",{parentName:"p"},"axiom my_wrong_axiom false"),".\nBecause ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," is never true for any interpretation, verification with this axiom will always succeed!"),(0,i.kt)("h4",{id:"the-exponential-function"},"The Exponential Function"),(0,i.kt)("p",null,"Remember that we want to prove a lower bound of ",(0,i.kt)("inlineCode",{parentName:"p"},"0.5^len(init_l)")," for the probability of a run without crashing.\nExponential functions are also not included in Caesar, but it can also be easily added."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-heyvl"},"domain Exponentials {\n    func exp(base: UReal, exponent: UInt): UReal\n\n    axiom exp_base forall base: UReal. exp(base, 0) == 1\n    axiom exp_step forall base: UReal, exponent: UInt. exp(base, exponent + 1) == base * exp(base, exponent)\n}\n")),(0,i.kt)("p",null,"We declare a domain ",(0,i.kt)("inlineCode",{parentName:"p"},"Exponentials"),".\nThe new type ",(0,i.kt)("inlineCode",{parentName:"p"},"Exponentials")," is not used, but all function definitions and axioms need a surrounding ",(0,i.kt)("inlineCode",{parentName:"p"},"domain"),".\nThe function ",(0,i.kt)("inlineCode",{parentName:"p"},"exp")," takes a base and an exponent of type ",(0,i.kt)("inlineCode",{parentName:"p"},"UReal")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"UInt"),", respectively.\nSee the ",(0,i.kt)("a",{parentName:"p",href:"/docs/stdlib/numbers"},"number types docs")," for more information."),(0,i.kt)("p",null,"There are two axioms for ",(0,i.kt)("inlineCode",{parentName:"p"},"exp"),".\nThe first, ",(0,i.kt)("inlineCode",{parentName:"p"},"exp_base")," specifies that ",(0,i.kt)("inlineCode",{parentName:"p"},"exp(base, 0) == 1")," holds for all ",(0,i.kt)("inlineCode",{parentName:"p"},"base")," values.\nThe second, ",(0,i.kt)("inlineCode",{parentName:"p"},"exp_step")," specifies the successive cases, ",(0,i.kt)("inlineCode",{parentName:"p"},"exp(base, exponent + 1) == base * exp(base, exponent)"),"."),(0,i.kt)("p",null,"You might wonder why we specify the exponential function in this inductive way and not via the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Characterizations_of_the_exponential_function"},"many other definitions of the exponential function that Wikipedia provides"),".\nAfter all, we are not restricted to inductively computable definitions and can use any logical specification we want, right?\nThe answer here is that those two axioms are precisely the ones needed to prove our specific property using our chosen proof rule of ",(0,i.kt)("a",{parentName:"p",href:"/docs/proof-rules/induction"},"Park induction"),".\nWe'll see this below.\nIn general, what axioms you need to provide for verification is often specific to the verification task at hand."),(0,i.kt)("p",null,"Refer to the ",(0,i.kt)("a",{parentName:"p",href:"/docs/heyvl/domains"},"documentation on domains and functions")," for more information."),(0,i.kt)("h3",{id:"specifications-and-invariants"},"Specifications and Invariants"),(0,i.kt)("p",null,"Now that we have provided all necessary definitions for the program, let us write the specification.\nRemember that we want to verify that the probability of a successful run without crashing is at least ",(0,i.kt)("inlineCode",{parentName:"p"},"exp(0.5, len(init_l))"),".\nHow do we specify such a property in HeyVL?"),(0,i.kt)("p",null,"HeyVL uses ",(0,i.kt)("em",{parentName:"p"},"expectation-based reasoning"),", which is a kind of deductive reasoning that talks about expected values of random variables.\nWe describe the full theoretical details in our ",(0,i.kt)("a",{parentName:"p",href:"/docs/publications#oopsla-23"},"OOPSLA '23 publication"),".\nFor now though, we'll provide some intuition."),(0,i.kt)("h4",{id:"specifications"},"Specifications"),(0,i.kt)("p",null,"We extend our ",(0,i.kt)("inlineCode",{parentName:"p"},"lossy_list")," declaration as follows with a ",(0,i.kt)("inlineCode",{parentName:"p"},"pre")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"post")," attribute:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-heyvl"},"proc lossy_list(init_l: List) -> (l: List)\n    pre [len(init_l) == 1] * 0.5\n    post [true]\n{ ... }\n")),(0,i.kt)("p",null,"What does this mean?\nExpectation-based reasoning always works backwards through the program.\nAccordingly, we start our interpretation with the ",(0,i.kt)("inlineCode",{parentName:"p"},"post"),".\nThe procedure having the post ",(0,i.kt)("inlineCode",{parentName:"p"},"[true]")," means that we are ultimately interested in reasoning about the ",(0,i.kt)("em",{parentName:"p"},"expected value of ",(0,i.kt)("inlineCode",{parentName:"em"},"[true]")," at termination"),".\nThe Iverson bracket notation ",(0,i.kt)("inlineCode",{parentName:"p"},"[b]")," maps a Boolean expression ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," evaluates to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and to ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," otherwise.\nTherefore, ",(0,i.kt)("inlineCode",{parentName:"p"},"[true]")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),".\nIt follows that ",(0,i.kt)("inlineCode",{parentName:"p"},"post [true]")," means we are interested simply in the probability of successful termination."),(0,i.kt)("p",null,"The pre ",(0,i.kt)("inlineCode",{parentName:"p"},"[len(init_l) == 1] * 0.5")," is a bit more interesting.\nIt results in a ",(0,i.kt)("em",{parentName:"p"},"proof obligation")," for Caesar: the verifier now needs to show that ",(0,i.kt)("em",{parentName:"p"},"the pre is always a lower bound to the expected value of the post"),".\nThe pre evaluates to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.5")," in case the length of the list is exactly one and to zero otherwise.\nSince the pre is checked as a lower bound (and expected values are nonnegative in HeyVL), Caesar in effect only checks that ",(0,i.kt)("inlineCode",{parentName:"p"},"0.5")," is a lower bound for inputs with list length equal to one."),(0,i.kt)("p",null,"Of course, we can also change the pre so that Caesar has to check infinitely many inputs, e.g. by changing the pre to ",(0,i.kt)("inlineCode",{parentName:"p"},"[len(init_l) != 1] * exp(0.5, len(init_l))"),".\nThanks to the magic of deductive reasoning and SMT solvers, this will also work instantly."),(0,i.kt)("h4",{id:"invariants"},"Invariants and Other Proof Rules"),(0,i.kt)("p",null,"Verification of programs with loops might require reasoning about an unbounded, possibly infinite number of loop iterations.\nIn deductive verification, we reduce reasoning of programs with loops to HeyVL programs without loops.\nThis is done using various ",(0,i.kt)("em",{parentName:"p"},"proof rules"),"."),(0,i.kt)("p",null,"In the non-probabilistic setting, the most famous one is the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Hoare_logic#While_rule"},"proof rule from Hoare logic (for partial correctness)")," which says that if we have an ",(0,i.kt)("em",{parentName:"p"},"invariant")," for a loop, i.e. a formula that holds before the loop and is maintained during the loop body's execution, then we may conclude that the invariant holds after the loop as well.\nThere is a direct correspondence to this rule in the probabilistic setting.\nWe call this rule ",(0,i.kt)("a",{parentName:"p",href:"/docs/proof-rules/induction"},"Park induction"),"."),(0,i.kt)("p",null,"To prove the desired pre being a lower bound on the expected value, we need find a ",(0,i.kt)("em",{parentName:"p"},"probabilistic invariant")," ",(0,i.kt)("inlineCode",{parentName:"p"},"I"),", i.e. an expression that computes an expected value for every program state, such that"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"If the loop condition is true, then ",(0,i.kt)("inlineCode",{parentName:"li"},"I")," must be a lower bound to the expected value of ",(0,i.kt)("inlineCode",{parentName:"li"},"I")," itself at the end of each single loop iteration,"),(0,i.kt)("li",{parentName:"ol"},"If the loop condition is false, then ",(0,i.kt)("inlineCode",{parentName:"li"},"I")," must be a lower bound to the post (in this case it's ",(0,i.kt)("inlineCode",{parentName:"li"},"[true] = 1"),").")),(0,i.kt)("p",null,"Note: There is a more formal description on the ",(0,i.kt)(o.Z,{to:"../proof-rules/induction",mdxType:"Link"},"documentation page for the Park induction proof rule"),"."),(0,i.kt)("p",null,"This proof rule corresponds to the general proof method of mathematical induction.\nThe base case is (2) when the loop condition is false and the inductive case is (1) when the loop condition is true, where we only reason about a single loop iteration."),(0,i.kt)("p",null,"So what is a valid invariant for our program?\nIt turns out that ",(0,i.kt)("inlineCode",{parentName:"p"},"exp(0.5, len(l))")," is a valid invariant:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"If the loop condition is true, then the expected value of ",(0,i.kt)("inlineCode",{parentName:"li"},"exp(0.5, len(l))")," at the end of the loop iteration is exactly ",(0,i.kt)("inlineCode",{parentName:"li"},"I"),"! Here's the calculation:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"  0.5 * exp(0.5, len(pop(l))) + 0.5 * 0\n= 0.5 * exp(0.5, len(pop(l)))            (simplify)\n= 0.5 * exp(0.5, len(l)-1)               (list_pop axiom)\n= exp(0.5, len(l))                       (exp_step axiom)\n"))),(0,i.kt)("li",{parentName:"ol"},"If the loop condition is false, then ",(0,i.kt)("inlineCode",{parentName:"li"},"I")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"exp(0.5, 0)")," which is equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," by the ",(0,i.kt)("inlineCode",{parentName:"li"},"exp_base")," axiom.")),(0,i.kt)("p",null,"Caesar has built-in support for Park induction with the ",(0,i.kt)("a",{parentName:"p",href:"/docs/proof-rules/induction"},(0,i.kt)("inlineCode",{parentName:"a"},"@invariant")," annotation for loops"),".\nWe add it on top of a loop statement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-heyvl"},"@invariant(exp(0.5, len(l)))\nwhile len(l) > 0 { ... }\n")),(0,i.kt)("p",null,"This is all we needed to do before we can verify this program.\nBefore we do so, a warning."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"HeyVL is an intermediate verification language and proof rules like Park induction must only be applied where it is sound with respect to the language semantics that we are considering.\nIn this case, by using Park induction in a ",(0,i.kt)("inlineCode",{parentName:"p"},"proc"),", we implicitly assumed ",(0,i.kt)("em",{parentName:"p"},"greatest fixed point")," semantics on unbounded non-negative expected values for the loop.\nIt assigns an infinite expected value to nonterminating executions.\nThen, Park induction is sound for lower bound reasoning only."),(0,i.kt)("p",{parentName:"admonition"},"A more common choice is ",(0,i.kt)("em",{parentName:"p"},"least fixed point")," semantics for loops, which assigns zero to nonterminating executions.\nThere, Park induction is sound only for ",(0,i.kt)("em",{parentName:"p"},"upper bound reasoning")," (",(0,i.kt)("a",{parentName:"p",href:"#upper-bounds"},"see below"),")."),(0,i.kt)("p",{parentName:"admonition"},"Refer to the ",(0,i.kt)("a",{parentName:"p",href:"../proof-rules/"},"proof rules documentation")," for more information on soundness of proof rules.")),(0,i.kt)("h3",{id:"full-example"},"Running the Complete Example"),(0,i.kt)("p",null,"We can now run Caesar on the full example file.\nThis file is also available in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/moves-rwth/caesar"},"Github repository")," at ",(0,i.kt)("inlineCode",{parentName:"p"},"tests/domains/lossy_list.heyvl"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-heyvl"},"domain Exponentials {\n    func exp(base: UReal, exponent: UInt): UReal\n\n    axiom exp_base forall base: UReal. exp(base, 0) == 1\n    axiom exp_step forall base: UReal, exponent: UInt. exp(base, exponent + 1) == base * exp(base, exponent)\n}\n\ndomain List {\n    func len(l: List): UInt\n    func pop(l: List): List\n\n    axiom list_pop forall l: List. len(pop(l)) == len(l) - 1\n}\n\nproc lossy_list(init_l: List) -> (l: List)\n    pre [len(init_l) == 1] * 0.5\n    post [true]\n{\n    l = init_l\n    @invariant(exp(0.5, len(l)))\n    while len(l) > 0 {\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice {\n            l = pop(l)\n        } else {\n            assert [false]\n        }\n    }\n}\n")),(0,i.kt)("p",null,"To verify this example using Caesar, simply run the following command in the Caesar source directory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"caesar tests/domains/lossy_list.heyvl\n")),(0,i.kt)("h3",{id:"upper-bounds"},"Reasoning About Upper Bounds (Coprocedures)"),(0,i.kt)("p",null,"In this example, we are reasoning about ",(0,i.kt)("em",{parentName:"p"},"lower bounds")," of expected values.\nIn classical non-probabilistic deductive verification, reasoning about lower bounds of truth values is the default and sufficient for most tasks (the recent interest in ",(0,i.kt)("em",{parentName:"p"},"incorrectness logics")," being a trend to the opposite).\nIn probabilistic, expectation-based reasoning though, it is just as natural to reason about upper bounds of expected values as about lower bounds.\nFor example, we'd like to prove an upper bound to the probability of a crash. ",(0,i.kt)("small",null,"This is not simply the opposite probability to the probability of a successful run when we also distinguish nontermination from crashes (we do!).")),(0,i.kt)("p",null,"HeyVL supports reasoning about upper bounds as well, via its ",(0,i.kt)("inlineCode",{parentName:"p"},"coproc"),"s.\nA ",(0,i.kt)("inlineCode",{parentName:"p"},"coproc")," is just like a ",(0,i.kt)("inlineCode",{parentName:"p"},"proc"),", but the ",(0,i.kt)("inlineCode",{parentName:"p"},"pre")," annotation is interpreted differently.\nInstead of noting a ",(0,i.kt)("em",{parentName:"p"},"lower bound")," on the expected value of the post, it now denotes an ",(0,i.kt)("em",{parentName:"p"},"upper bound")," of the post.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"co")," prefix indicates that the declaration is dual (in a mathematical sense) to the ",(0,i.kt)("inlineCode",{parentName:"p"},"proc")," one.\nHeyVL also has dual ",(0,i.kt)("inlineCode",{parentName:"p"},"co"),"-versions of its ",(0,i.kt)("a",{parentName:"p",href:"#verification-statements"},"verification statements"),", which will be introduced later."),(0,i.kt)("p",null,"Consider the following ",(0,i.kt)("inlineCode",{parentName:"p"},"coproc")," example (with the domain declarations from above omitted):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-heyvl"},"coproc lossy_list_up(init_l: List) -> (l: List)\n    pre 0\n    post len(l)\n{\n    l = init_l\n    @invariant(exp(0.5, len(l)))\n    while len(l) > 0 {\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice {\n            l = pop(l)\n        } else {\n            assert [false]\n        }\n    }\n}\n")),(0,i.kt)("p",null,"In this example, we prove an upper bound of zero to the expected value of ",(0,i.kt)("inlineCode",{parentName:"p"},"len(l)")," on termination.\nFor simplicity, we'll use ",(0,i.kt)("a",{parentName:"p",href:"/docs/proof-rules/induction"},"Park induction")," again."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"We are now using Park induction with upper bounds, which means the proof rule only gives us an upper bound to the ",(0,i.kt)("em",{parentName:"p"},"least fixed point")," of the loop semantics.\nBefore, we reasoned about greatest fixed point semantics!"),(0,i.kt)("p",{parentName:"admonition"},"As we've said above, the least fixed point semantics assigns expected value ",(0,i.kt)("strong",{parentName:"p"},"zero")," to nonterminating runs (as opposed to ",(0,i.kt)("strong",{parentName:"p"},"infinity")," for greatest fixed point semantics).\nThus, now we are only proving an upper bound on the expected value of ",(0,i.kt)("inlineCode",{parentName:"p"},"len(l)")," ",(0,i.kt)("em",{parentName:"p"},"only for the terminating executions AND those which do not crash"),".\nIf we hit the ",(0,i.kt)("inlineCode",{parentName:"p"},"assert [false]")," statement, then the expected value will be zero and those executions will verify trivially since HeyVL's expected values are always nonnegative."),(0,i.kt)("p",{parentName:"admonition"},"Caesar has other proof rules built-in that allow reasoning about lower bounds of least fixed points and upper bounds of greatest fixed points.\nSee the ",(0,i.kt)("a",{parentName:"p",href:"../proof-rules/"},"proof rules documentation"),".")),(0,i.kt)("h2",{id:"verification-statements"},"Verification Statements"),(0,i.kt)("p",null,'In addition to HeyVL\'s "normal" programming constructs such as assignments ',(0,i.kt)("inlineCode",{parentName:"p"},"x = e"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"if (b) { ... } else { ... }"),", Caesar has statements that are specific to program verification.\nThere are ",(0,i.kt)("inlineCode",{parentName:"p"},"assert")," statements which add proof obligations, ",(0,i.kt)("inlineCode",{parentName:"p"},"assume")," statements which allow to add assumptions, and nondeterministic choices."),(0,i.kt)("p",null,"In the following, we'll explain HeyVL's verification statements by explaining how the ",(0,i.kt)("a",{parentName:"p",href:"#full-example"},"lossy list example")," is internally rewritten to loop-free HeyVL code with verification statements.\nFor reference-level documentation, refer to the ",(0,i.kt)("a",{parentName:"p",href:"/docs/heyvl/statements"},"HeyVL statements documentation"),"."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Our ",(0,i.kt)("a",{parentName:"p",href:"/docs/publications#oospla-23"},"OOPLSA '23 publication ",(0,i.kt)("em",{parentName:"a"},'"A Deductive Verification Infrastructure for Probabilistic Programs"'))," (",(0,i.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/2309.07781.pdf"},"direct link to extended version pdf"),") is a formal treatment of HeyVL's verification statements.\nIt is a highly recommended read to understand HeyVL's verification statements in detail and from the bottom up.")),(0,i.kt)("h3",{id:"boolean-verification-statements"},"Boolean Verification Statements"),(0,i.kt)("p",null,"HeyVL's verification statements are quantitative generalizations of classical verification statements that can be found in deductive verifiers such as ",(0,i.kt)("a",{parentName:"p",href:"https://dafny.org/"},"Dafny"),".\nThis means that when we only reason about Boolean properties, i.e. whether a property holds in certain states or not (as opposed to expected values of such predicates), then HeyVL's verification statements behave ",(0,i.kt)("em",{parentName:"p"},"exactly")," as their qualitative (Boolean) counterparts.\nThis is why we'll start our explanation with non-probabilistic intuition before we delve into more detail about ",(0,i.kt)("a",{parentName:"p",href:"#expectation-based-reasoning"},(0,i.kt)("em",{parentName:"a"},"expectation-based reasoning")),", the generalization to the quantitative setting."),(0,i.kt)("h4",{id:"embed-expressions"},"Embed Expressions"),(0,i.kt)("p",null,"An embed ",(0,i.kt)("a",{parentName:"p",href:"/docs/heyvl/expressions"},"expression")," ",(0,i.kt)("inlineCode",{parentName:"p"},"?(b)")," takes a Boolean expression ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," and maps it to ",(0,i.kt)("inlineCode",{parentName:"p"},"\u221e")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," evaluates to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and to ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," otherwise.\nIt can be expressed by Iverson brackets ",(0,i.kt)("inlineCode",{parentName:"p"},"[b]")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"[b] * \u221e"),"."),(0,i.kt)("p",null,"Thus, embed expressions ",(0,i.kt)("em",{parentName:"p"},"embed")," Boolean expressions into the quantitative verification domain that Caesar uses where values are not just ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", but everything from the real number ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," up to and including ",(0,i.kt)("inlineCode",{parentName:"p"},"\u221e"),"."),(0,i.kt)("h4",{id:"boolean-assertions"},"Boolean Assertions"),(0,i.kt)("p",null,"A Boolean assertion is used to say that a predicate is true at this location.\nFor example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-heyvl"},"assert ?(len(init_l) > 0)\n")),(0,i.kt)("p",null,"will require that ",(0,i.kt)("inlineCode",{parentName:"p"},"len(init_l)")," is at least one."),(0,i.kt)("h4",{id:"boolean-assumptions"},"Boolean Assumptions"),(0,i.kt)("p",null,"A Boolean assumption is used to instruct the verifier that a Boolean expression can be assumed to be true at this point without proof.\nFor example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-heyvl"},"assume ?(len(init_l) == 1)\n")),(0,i.kt)("p",null,"will assume that ",(0,i.kt)("inlineCode",{parentName:"p"},"len(init_l)")," is one.\nExecutions that do not satisfy the Boolean expression are ignored by the verifier."),(0,i.kt)("p",null,"For example, consider this piece of code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-heyvl"},"assume ?(len(init_l) == 1); assert ?(len(init_l) > 0)\n")),(0,i.kt)("p",null,"The assertion will never fail since we assume in all executions that the assertion ",(0,i.kt)("inlineCode",{parentName:"p"},"len(init_l) == 1")," is true and thus also ",(0,i.kt)("inlineCode",{parentName:"p"},"len(init_l) > 0")," holds."),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"assume ?(false)")," will assume ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", i.e. everything following after this statement will verify."),(0,i.kt)("h3",{id:"expectation-based-reasoning"},"Expectation-Based Reasoning"),(0,i.kt)("h3",{id:"assumptions-and-assertions"},"Assumptions and Assertions"),(0,i.kt)("h3",{id:"havoc"},"Havoc"),(0,i.kt)("h3",{id:"nondeterministic-choice"},"Nondeterministic Choice"),(0,i.kt)("h3",{id:"rewards"},"Rewards"))}h.isMDXComponent=!0}}]);